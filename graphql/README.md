# GraphQL for Lernfair

We try to leverage GraphQL as a query language for our API.
Maybe we're able to reduce complexity a bit with that (a lot of repetition in CRUD endpoints, a lot of data "massaging", missing authorizations / validations).

We're using ApolloGraphQL as the runtime implementation, TypeGraphQL to automatically turn Typescript types into GraphQL Schemas, and TypeGraphQL-Prisma to automatically generate simple CRUD Mutations from the Prisma (database) Schema. Prisma is our ORM (alongside TypeORM, thus `npx prisma introspect` needs to be run once in a while to keep the schemas in sync).

To rebuild the Prisma runtime and autogenerated TypeGraphQL types (found in `/graphql/generated/`) run `npx prisma generate`.
We currently do this manually and check the results into version control, as typegraphql-prisma is still very experimental.

Please DO NOT manually change the `/graphql/generated` folder. If changes are needed, have a look at the [Resolver Enhance Maps](https://prisma.typegraphql.com/docs/advanced/additional-decorators), or [write your own Resolvers / Fields](https://prisma.typegraphql.com/docs/advanced/custom-operations) outside of that folder.

The GraphQL can be explored when visiting `https://[backend-host]/apollo` which shows an interactive UI. Add `{ "authorization": "[SECRET ACCESS TOKEN]" }` to the HTTP Headers field, then you should be able to perform a query like:

```gql
query {
    pupils(where: { firstname: { contains: "M" } }) {
        id
        firstname
        lastname
    }
}
```

-   [Learn GraphQL](https://graphql.org/learn/)
-   [Apollo Documentation](https://www.apollographql.com/docs/apollo-server/)
-   [TypegraphQL Documentation](https://typegraphql.com/docs/introduction.html)
-   [TypeGraphQL Prisma](https://prisma.typegraphql.com/docs/)

-   [Make a Walkthrough through the available queries and mutations](./WALKTHROUGH.md)

## Naming Conventions

We generally use camelCase if no external constraints apply.

Entities (top level resolvers) are autogenerated through Prisma in snake_case, we do not change that for consistency
and also follow it in associations. Resolvers that apply additional filtering should be prefixed by the superset (e.g. `pupils`, `pupilsActivated`, `pupilsSearch`).

Mutations are unfortunately not associated to an entity technically, however we can still associate them semantically
by prefixing mutations by the main entity (e.g. `pupilActivate`).
Mutations that `create`, `update` or `delete` an entity should be named as such.

Mutations shall be placed in `/graphql/[entity]/mutations.ts`, field resolvers in `/graphql/[entity]/fields.ts`.
The classes shall be named `Mutate[Entity]Resolver` and `ExtendedFields[Entity]Resolver`.

## Coding Conventions

If an error is thrown inside a resolver or a mutation an internal server error response is sent to the GraphQL client,
thus error handling is generally not needed. Error messages should generally not contain any secrets.

Mutations that modify an entity shall have the entity's primary key as the first parameters.
If the entity does not exist, the mutation should throw (in `/graphql/util.ts` there are helpers to do exactly that).

Unfortunately Mutations cannot be "void" but [have to return a value](https://stackoverflow.com/questions/44737043/is-it-possible-to-not-return-any-data-when-using-a-graphql-mutation),
thus mutations which cannot return anything useful return a boolean and end with `return true`.

All resolvers and mutations must be annotated with `@Authorized` to ensure they're not accessible _by anyone_.
For autogenerated entities this is done in `/graphql/authorizations.ts`.

Associations should be annotated with `@LimitEstimated` to ensure that the backend does not time out or run out of memory,
or if the association as high cardinality, it should accept the parameters `take` and `skip` implementing pagination and should be annotated with `@LimitedQuery`.

Don't change anything in `graphql/generated/*` (except for regenerating Prisma changes).
