// This Schema is the single source of truth for our data model
// From it we generate
// - SQL Migrations to set up / migrate the underlying PostgreSQL databases
// - Typescript Types to make all the logic on top of the data typesafe
// - GraphQL Resolvers, to automatically expose the data to clients (enriched with authorization checks)
//
// Previously we used TypeORM as our ORM, and before that the database was migrated manually,
// and we still have some legacy from that time (i.e. 'strings as json' ...)

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["orderByNulls"]
}

// 'prisma generate' also generates GraphQL Resolvers:
generator typegraphql {
  provider = "typegraphql-prisma"
  output   = "../graphql/generated"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Achievement
// A final achievement can consist of several sub-achievements
model achievement_template {
  id                        Int                           @id @default(autoincrement())
  templateFor               achievement_template_for_enum
  // Achievements can
  // - cross-platform (i.e. for one user) 
  // - across all offers (globally for all courses or for all matches) 
  // - or specifically for one offer (eg `match/{{matchId}}`)
  // We need the group for this in order to be able to assign it correctly later.
  // e.g. "onboarding", "regular_learning/{{matchId}}", "course_completed/{{courseId}}" ""
  group                     String                        @db.VarChar
  // An achievement can also consist of sub-achievements, 
  // e.g. in the case of sequential achievements, each step is seen as a separate achievement (sub-achievement). 
  // In the case of tiered achievements, for example, each tier is a separate achievement but belongs to a group. 
  // The groupOrder therefore determines the order of the sub-achievements.
  groupOrder                Int
  // what type of achievement is it
  type                      achievement_type_enum
  image                     String                        @db.VarChar
  achievedImage             String?                       @db.VarChar
  // some achievements show actions that a user can/must perform next.
  // therefore we need the action name, type (for the icon) and a redirect link
  actionName                String?                       @db.VarChar
  actionRedirectLink        String?                       @db.VarChar
  actionType                achievement_action_type_enum?
  // defines what value must be reached to receive the achievement, 
  // e.g. "duration == 60", "count == 5", "count == 3 & duration == 60", "series >= 5" (https://github.com/onlabsorg/swan-js)
  condition                 String                        @db.VarChar
  // defines how values must be aggregated to evaluate the condition
  // it also contains bucket aggregators (buckets are used for aggregate values for a specific time of period)
  conditionDataAggregations Json                          @db.Json
  isActive                  Boolean
  user_achievement          user_achievement[]

  // Text related fields
  tagline             String? @db.VarChar
  title               String  @db.VarChar
  subtitle            String? @db.VarChar
  description         String  @db.VarChar
  achievedDescription String? @db.VarChar
  footer              String? @db.VarChar
  achievedFooter      String? @db.VarChar

  // Sequential: each step is seen as a separate achievement and each step has its own name                   
  sequentialStepName String? @db.VarChar
}

model user_achievement {
  id          Int                  @id @default(autoincrement())
  relation    String?
  // the id of the relating achievement_template
  templateId  Int
  template    achievement_template @relation(fields: [templateId], references: [id])
  userId      String
  isSeen      Boolean              @default(false)
  // achievedAt == null => not achieved, achievedAt != null => achieved
  achievedAt  DateTime?            @db.Timestamp(6)
  // Streaks: we have to store the highest record for streaks
  recordValue Int?
  context     Json                 @db.Json

  @@unique([relation, userId, templateId], name: "unique_user_achievement")
}

// Save (tracked) event as raw data in DB and evaluate at runtime
model achievement_event {
  id        Int      @id @default(autoincrement())
  userId    String   @db.VarChar
  metric    String   @db.VarChar
  // the value is calculated with the formula given in the metric
  value     Int
  createdAt DateTime @default(now()) @db.Timestamp(6)
  // what action triggered the event
  action    String   @db.VarChar
  // the relation is like a unique id so that we can later assign the event uniquely, e.g. "course/10", "match/12", "user/10"
  relation  String?  @db.VarChar
}

// An attachment is a file uploaded to an object storage and attached to a notification
// We also store it in the DB to be able to track the file's lifecycle, i.e. delete it when the notification is archived
model attachment {
  id                String   @id(map: "PK_d2a80c3a8d467f08a750ac4b420") @default(dbgenerated("uuid_generate_v4()")) @db.Uuid
  uploaderID        String   @db.VarChar
  filename          String   @db.VarChar
  size              Int
  // The attachmentGroupId acts as an n to m mapping between concrete notifications and attachments
  attachmentGroupId String   @db.VarChar
  date              DateTime @db.Timestamp(6)
}

// DEPRECATED
// Was used for course meetings before Zoom was introduced in Summer 2023
model bbb_meeting {
  id             Int      @id(map: "PK_33f2c503196edee1b2e5899083f") @default(autoincrement())
  createdAt      DateTime @default(now()) @db.Timestamp(6)
  updatedAt      DateTime @default(now()) @updatedAt @db.Timestamp(6)
  meetingID      String   @db.VarChar
  meetingName    String?  @db.VarChar
  attendeePW     String?  @db.VarChar
  moderatorPW    String?  @db.VarChar
  alternativeUrl String?  @db.VarChar
}

// We sometimes have cooperations with companies / other non-profits, and might want to associate accounts with it
model cooperation {
  id             Int       @id() @default(autoincrement())
  name           String
  // This is a short string which can be passed in to the registration to associate users with this
  tag            String
  // Text shown to users on the registration page
  welcomeTitle   String
  welcomeMessage String
  student        student[]
}

// A Concrete Notification represents a Notification sent to one specific user
model concrete_notification {
  id                Int           @id(map: "PK_830b05c48e7ba274a9e4bceced3") @default(autoincrement())
  userId            String        @db.VarChar
  notificationID    Int
  // The contextID moves context.uniqueId out of the JSON field, to be able to query it efficiently:
  contextID         String?       @db.VarChar
  context           Json          @db.Json
  attachmentGroupId String?       @db.VarChar
  sentAt            DateTime      @db.Timestamp(6)
  state             Int // This should be an enum
  error             String?       @db.VarChar
  notification      notification? @relation(fields: [notificationID], references: [id], onDelete: NoAction, onUpdate: NoAction)
}

// A Course acts as a template for multiple Subcourses
// (though historically the UI was never built to reuse a Course, so most Courses have exactly one Subcourse)
model course {
  id                         Int                          @id(map: "PK_bf95180dd756fd204fb01ce4916") @default(autoincrement())
  createdAt                  DateTime                     @default(now()) @db.Timestamp(6)
  updatedAt                  DateTime                     @default(now()) @updatedAt @db.Timestamp(6)
  name                       String                       @db.VarChar
  outline                    String                       @db.VarChar
  description                String                       @db.VarChar
  // The imageKey refers to a file in the object store and can be resolved to a file URL
  imageKey                   String?                      @db.VarChar
  category                   course_category_enum
  subject                    course_subject_enum?
  schooltype                 course_schooltype_enum[]     @default([other])
  // The courseState represents the course approval flow, where the Support checks and approves courses
  // Created -> Submitted -> Approved
  courseState                course_coursestate_enum      @default(created)
  screeningComment           String?                      @db.VarChar
  // DEPRECATED: The publicRanking was used historically to order courses in the UI
  publicRanking              Int                          @default(0)
  allowContact               Boolean                      @default(false)
  // DEPRECATED: The correspondent was historically used as the main contact responsible
  //             Instead, use the course_instructors_student relation
  correspondentId            Int?
  student                    student?                     @relation(fields: [correspondentId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_0682a6fe3bace3ed13377c1b1ca")
  course_guest               course_guest[]
  course_instructors_student course_instructors_student[]
  course_tags_course_tag     course_tags_course_tag[]
  subcourse                  subcourse[]
  shared                     Boolean                      @default(false)
}

// DEPRECATED: This was filled from BBB Meetings, replaced with the zoomMeetingReports field of lectures
model course_attendance_log {
  id           Int      @id(map: "PK_c3906899bb64b97b840ea1f2656") @default(autoincrement())
  createdAt    DateTime @default(now()) @db.Timestamp(6)
  updatedAt    DateTime @default(now()) @updatedAt @db.Timestamp(6)
  attendedTime Int?
  ip           String?  @db.VarChar
  pupilId      Int?
  lectureId    Int?
  lecture      lecture? @relation(fields: [lectureId], references: [id], onDelete: Cascade, map: "FK_927959c3480126ecdceeae26609")
  pupil        pupil?   @relation(fields: [pupilId], references: [id], onDelete: Cascade, map: "FK_acc59dc4321a888376f7fad5a3d")
}

// DEPRECATED: This was used historically to invite guests to BBB Course Meetings
model course_guest {
  id        Int      @id(map: "PK_f12462c16c543cf76ed1fa49289") @default(autoincrement())
  createdAt DateTime @default(now()) @db.Timestamp(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamp(6)
  token     String   @unique(map: "IDX_8fb7b15823c3ed0fea3c508ac4") @db.VarChar
  firstname String   @db.VarChar
  lastname  String   @db.VarChar
  email     String   @db.VarChar
  courseId  Int?
  inviterId Int?
  course    course?  @relation(fields: [courseId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_4392726b6462358a809db822af4")
  student   student? @relation(fields: [inviterId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_a0843258a46daa7d91dc2cef917")
}

// A course instructor can edit a course and create subcourses from it
model course_instructors_student {
  courseId  Int
  studentId Int
  course    course  @relation(fields: [courseId], references: [id], onDelete: Cascade, map: "FK_54bce9a9a93ae130beaa70bb2fa")
  student   student @relation(fields: [studentId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_66b47860afa3098729925338c18")

  @@id([courseId, studentId], map: "PK_aa54b28c5de0010f486dd0d72df")
  @@index([courseId], map: "IDX_54bce9a9a93ae130beaa70bb2f")
  @@index([studentId], map: "IDX_66b47860afa3098729925338c1")
}

// DEPRECATED: Course Instructors were able to send a participation certificate to some participants of a course
model course_participation_certificate {
  id          Int        @id(map: "PK_ee8536af11485574445cf6c0b0e") @default(autoincrement())
  createdAt   DateTime   @default(now()) @db.Timestamp(6)
  updatedAt   DateTime   @default(now()) @updatedAt @db.Timestamp(6)
  issuerId    Int?
  pupilId     Int?
  subcourseId Int?
  pupil       pupil?     @relation(fields: [pupilId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_585aa209315fc328d48af2765b4")
  subcourse   subcourse? @relation(fields: [subcourseId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_bc6a26ac82132b6e9f1d6de3e4c")
  student     student?   @relation(fields: [issuerId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_d03c3421018dd300f5e9061ae87")
}

model course_tag {
  id                     Int                      @id(map: "PK_6c6a0ad4b5f67db91353e5b2ae1") @default(autoincrement())
  // DEPRECATED: Both id and (name, category) are unique, no need for another unique "identifier"
  identifier             String                   @unique(map: "IDX_275561ded9309f727f8e795bf1") @db.VarChar
  name                   String                   @db.VarChar
  category               String                   @db.VarChar
  course_tags_course_tag course_tags_course_tag[]
  active                 Boolean                  @default(true)
}

model course_tags_course_tag {
  courseId    Int
  courseTagId Int
  course_tag  course_tag @relation(fields: [courseTagId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_af4499c3ae1153ac06782b2e5b9")
  course      course     @relation(fields: [courseId], references: [id], onDelete: Cascade, map: "FK_d6261ad9de1fc5f06946095bf8c")

  @@id([courseId, courseTagId], map: "PK_3996cf424477234b88a0980fd39")
  @@index([courseTagId], map: "IDX_af4499c3ae1153ac06782b2e5b")
  @@index([courseId], map: "IDX_d6261ad9de1fc5f06946095bf8")
}

// If a Student wants to hold Courses, they are screened as Instructors by the Support Team
// Durinng the Screening we also collect some additional user information
model instructor_screening {
  id                    Int                           @id(map: "PK_e29a51f8dce0a07d2e1dba73636") @default(autoincrement())
  status                student_screening_status_enum @default(pending)
  comment               String?                       @db.VarChar
  jobStatus             screening_jobstatus_enum?
  // This is a String and not an enum to be able to quickly support further values without a DB migration,
  // and to be able to cover 'Sonstiges'. In the Screening Tooling, we however always write the same strings into it,
  // so a COUNT(*) GROUP BY should work relatively well:
  knowsCoronaSchoolFrom String?                       @db.VarChar
  createdAt             DateTime                      @default(now()) @db.Timestamp(6)
  updatedAt             DateTime                      @default(now()) @updatedAt @db.Timestamp(6)
  screenerId            Int?
  studentId             Int?                          @unique(map: "REL_e176665fa769d2e603d825f6fa")
  student               student?                      @relation(fields: [studentId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_e176665fa769d2e603d825f6fa3")
  screener              screener?                     @relation(fields: [screenerId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_ef1d3e862feda89b92fddcdbb34")
  lecture               lecture[]
}

// DEPRECATED: We once had a cooperation with Jugend Forscht ("jufo")
model jufo_verification_transmission {
  id        Int      @id(map: "PK_3e81acd237ad0b7e97003c835d8") @default(autoincrement())
  createdAt DateTime @default(now()) @db.Timestamp(6)
  uuid      String   @db.VarChar
  studentId Int?     @unique(map: "REL_1ceddec34e7b90cdbb85ff9738")
  student   student? @relation(fields: [studentId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_1ceddec34e7b90cdbb85ff9738f")
}

// A topic a pupil is currently learning in a certain subject
// This is used to group notes and assignments
model learning_topic {
  id        Int      @id() @default(autoincrement())
  createdAt DateTime @default(now()) @db.Timestamp(6)

  pupilId Int
  pupil   pupil @relation(fields: [pupilId], references: [id], onDelete: NoAction, onUpdate: NoAction)

  name    String
  subject course_subject_enum

  matchId Int?
  match   match? @relation(fields: [matchId], references: [id], onDelete: NoAction, onUpdate: NoAction)

  assignments learning_assignment[]
  notes       learning_note[]
}

enum learning_assignment_status {
  pending
  in_progress
  done
}

// A certain task a pupil is supposed to do, both small "solve equation XY" or large "write an analysis for book XY"
model learning_assignment {
  id        Int      @id() @default(autoincrement())
  createdAt DateTime @default(now()) @db.Timestamp(6)

  topicId Int
  topic   learning_topic @relation(fields: [topicId], references: [id], onDelete: NoAction, onUpdate: NoAction)

  task   String
  status learning_assignment_status

  notes learning_note[]
}

enum learning_note_type {
  question // from the pupil

  answer // providing the solution to the assignment
  correct_answer // answer marked as correct by the helper
  wrong_answer // answer marked as wrong by the helper or tool

  task // Ask the pupil to do something for the assignment or topic

  comment
}

// Learning notes are semi-structured collection of texts and images for an assignment or topic
// which are shared by a pupil, their match partner and assisting tools
model learning_note {
  id        Int      @id() @default(autoincrement())
  createdAt DateTime @default(now()) @db.Timestamp(6)

  type learning_note_type

  authorID   String? // userID, NULL if from a tool
  authorName String

  // Linked to an assignment XOR topic

  topicId Int?
  topic   learning_topic? @relation(fields: [topicId], references: [id], onDelete: NoAction, onUpdate: NoAction)

  assignmentId Int?
  assignment   learning_assignment? @relation(fields: [assignmentId], references: [id], onDelete: NoAction, onUpdate: NoAction)

  text String
  // image, file, ...

  replyToId Int?
  replyTo   learning_note?  @relation(name: "reply", fields: [replyToId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  repliedBy learning_note[] @relation(name: "reply")
}

// Till Summer 2023 we only offered "Course Lectures", so a meeting for a Subcourse at a particular point in time
// Then we evolved "Course Lectures" into "Appointments", were any group of users could meet together.
// In the codebase we call this 'appointment' and also still 'lecture'
model lecture {
  id                    Int                          @id(map: "PK_2abef7c1e52b7b58a9f905c9643") @default(autoincrement())
  createdAt             DateTime                     @default(now()) @db.Timestamp(6)
  updatedAt             DateTime                     @default(now()) @updatedAt @db.Timestamp(6)
  start                 DateTime                     @db.Timestamp(6)
  duration              Int // in minutes
  title                 String?
  description           String?
  appointmentType       lecture_appointmenttype_enum @default(legacy)
  isCanceled            Boolean?                     @default(false)
  // A set of UserIDs of users that can modify the appointment:
  organizerIds          String[]                     @default([])
  // A set of UserIDs of users that only participate:
  participantIds        String[]                     @default([])
  // A subset of organizerIds and participantIds that have declined the appointment:
  declinedBy            String[]                     @default([])
  // A subset of UserIDs of users that joined the meeting
  joinedBy              String[]                     @default([])
  // A Zoom Meeting might be attached to an Appointment (unless Zoom is turned off):
  zoomMeetingId         String?                      @db.VarChar
  // When an organizer leaves a Zoom Meeting, we collect a Zoom Meeting Report from the API:
  zoomMeetingReport     Json[]                       @default([]) @db.Json
  // Calendly Event URL, we can use this go get additional information about the appointment
  // For calendly, it's also kind of an id
  eventUrl              String?
  // An appointment might be related to a Screening, i.e. a Pupil Screening or Tutor Screening
  pupilScreeningId      Int?
  tutorScreeningId      Int?
  instructorScreeningId Int?
  // DEPRECATED: This was used for Course Lectures before the evolution to Appointments. Use organizerIds instead
  instructorId          Int?
  // An Appointment might be related to a Subcourse or a Match - but it can also be a standalone meeting:
  subcourseId           Int?
  matchId               Int?
  subcourse             subcourse?                   @relation(fields: [subcourseId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_087916363d2c5b483701d505a07")
  student               student?                     @relation(fields: [instructorId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_2ca61c8451b53ad2da3c5f6432a")
  match                 match?                       @relation(fields: [matchId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_5829da504d003d9aa252856574e")
  pupilScreening        pupil_screening?             @relation(fields: [pupilScreeningId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  tutorScreening        screening?                   @relation(fields: [tutorScreeningId], references: [id], onDelete: SetNull, onUpdate: NoAction)
  instructorScreening   instructor_screening?        @relation(fields: [instructorScreeningId], references: [id], onDelete: SetNull, onUpdate: NoAction)
  course_attendance_log course_attendance_log[]
  // Support can set this if organizer prefers a different meeting platform over zoom; if this is set, don't create zoom meeting
  override_meeting_link String?
}

// The Transaction Log is supposed to store a history of business transactions for a user,
// however as this is not filled consistently across the codebase one can only see half of the user actions
model log {
  id        Int              @id(map: "PK_350604cbdf991d5930d9e618fbd") @default(autoincrement())
  logtype   log_logtype_enum @default(misc)
  createdAt DateTime         @default(now()) @db.Timestamp(6)
  userID    String?          @db.VarChar
  // This is usually valid JSON:
  data      String           @db.VarChar
}

model match {
  id                    Int                @id(map: "PK_92b6c3a6631dd5b24a67c69f69d") @default(autoincrement())
  // DEPRECATED: The uuid was used to generate non-guessable meeting room links, replaced by Appointments/Zoom
  uuid                  String             @unique(map: "IDX_65a3ec8c0aa6c3c9c04f5b53e3") @db.VarChar
  dissolved             Boolean            @default(false)
  dissolvedAt           DateTime?          @db.Timestamp(6)
  dissolvedBy           dissolved_by_enum?
  dissolveReasons       dissolve_reason[]  @default([])
  otherDissolveReason   String?            @db.VarChar // user can enter detailed explanation when selected dissolve reason is "other"
  didHaveMeeting        Boolean            @default(false) // whether the match partners did actually have an initial meeting
  // DEPRECATED: At some point students could suggest a first meeting time to pupils when they got the match
  // The functionality was removed a long time ago, and is generally replaced with Appointments
  proposedTime          DateTime?          @db.Timestamp(6)
  createdAt             DateTime           @default(now()) @db.Timestamp(6)
  updatedAt             DateTime           @default(now()) @updatedAt @db.Timestamp(6)
  // DEPRECATED: With the Notification System we now use Concrete Notifications to track 
  // whether a notification was already sent. These booleans were used a long time ago by some cron jobs:
  feedbackToPupilMail   Boolean            @default(false)
  feedbackToStudentMail Boolean            @default(false)
  followUpToPupilMail   Boolean            @default(false)
  followUpToStudentMail Boolean            @default(false)

  // FirstMatchRequest - createdAt gives a rough estimate how long a student / pupil had to wait for a match
  // As a user can create multiple match requests, and we do not know which match request lead to which match,
  // we store the time of the first match request. So this can be seen as an upper boundary, but the average user
  // has only one match request at a time anyways
  studentFirstMatchRequest DateTime? @db.Timestamp(6)
  pupilFirstMatchRequest   DateTime? @db.Timestamp(6)

  // Since the introduction of Match Pools we also track whether a match was created for Lern-Fair Now or Lern-Fair Plus.
  // Previously one could not distinguish plus and now matches
  matchPool String?   @db.VarChar
  studentId Int?
  pupilId   Int?
  pupil     pupil?    @relation(fields: [pupilId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_38770d911dab69557a913812f3f")
  student   student?  @relation(fields: [studentId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_89d8d61ff2bcae46513788416e4")
  lecture   lecture[]

  learning_topics learning_topic[]

  // For "automatic matches", stores the Match Run that created this match (since 01/2025)
  matchPoolRunId Int?
  matchPoolRun   match_pool_run? @relation(fields: [matchPoolRunId], references: [id], onDelete: NoAction, onUpdate: NoAction)

  // Pupils never get matched to the same Student again,
  // if they want to continue their match we reactivate the existing match instead
  @@unique([studentId, pupilId], name: "UQ_MATCH", map: "UQ_MATCH")
}

// A template for a Notification sent to a User
model notification {
  id                    Int                         @id(map: "PK_705b6c7cdf9b2c2ff7ac7872cb7") @default(autoincrement())
  // If set, the user is notified via Mail using this template:
  mailjetTemplateId     Int?
  description           String                      @db.VarChar
  active                Boolean
  // An enum, was intended to be able to i.e. notify the teacher or parent of a pupil
  // Never used in reality so far
  recipient             Int
  onActions             String[]
  // Users can toggle notifications on or off per type:
  type                  notification_type_enum      @default(legacy)
  cancelledOnAction     String[]
  // If set, the notification is not sent immeadiately but after the delay:
  delay                 Int? // hours
  // If set, the notification is repeated indefinetly till an action in the 'cancelledOnAction' list is triggered:
  interval              Int? // hours
  // The sender influences the sender email address, so that replies directly go to the correct team
  sender                notification_sender_enum?
  // If set a hook is executed when the Notification is sent out:
  hookID                String?                     @db.VarChar
  // For Notifications that are not related to any actions (= campaigns), this provides a sample context
  // For Notifications with actions one can just take the subset of all sample contexts of all actions
  // This is used to validate message templates to only use the right variables, and to show a rich UI in Retool
  // for maintaining notifications
  sample_context        Json?                       @db.Json
  // If set, the user gets in-app notifications:
  message_translation   message_translation[]
  disabledChannels      notification_channel_enum[] @default([])
  concrete_notification concrete_notification[]
}

// A certificate that a student helped one pupil (= match), signed by the pupil or their parents
model participation_certificate {
  id                Int       @id(map: "PK_431b3e203adb26c29ecef120034") @default(autoincrement())
  // Non-guessable, used for the public verification endpoint that everyone can visit to check that a certificate was issued by us
  uuid              String    @unique(map: "IDX_5c7ebcd2f3fc7ed6022a478980") @db.VarChar
  // comma-separated strings:
  subjects          String    @db.VarChar
  categories        String    @db.VarChar
  certificateDate   DateTime  @default(now()) @db.Timestamp(6)
  startDate         DateTime  @default(now()) @db.Timestamp(6)
  endDate           DateTime  @default(now()) @db.Timestamp(6)
  hoursPerWeek      Decimal   @db.Decimal
  hoursTotal        Decimal   @db.Decimal
  medium            String    @db.VarChar
  ongoingLessons    Boolean   @default(false)
  // enum, can be 'manual' if the pupil signs the certificate manually be downloading it,
  // or 'awaiting-approval' -> 'aproved' if the signature functionality of the user app is used
  state             String    @default("manual") @db.VarChar
  // Either the signaturePupil or signatureParent is set, depending on whether the pupil is a minor and needs the signature of their parent
  signaturePupil    Bytes?
  signatureParent   Bytes?
  signatureLocation String?   @db.VarChar
  signatureDate     DateTime? @db.Timestamp(6)
  studentId         Int?
  pupilId           Int?
  pupil             pupil?    @relation(fields: [pupilId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_01437dc10f00eace91b0f93a805")
  student           student?  @relation(fields: [studentId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_b8bb6da6b807a7b382218947647")
}

model instant_certificate {
  id                        Int      @id @default(autoincrement())
  createdAt                 DateTime @default(now()) @db.Timestamp(6)
  // Non-guessable, used for the public verification endpoint that everyone can visit to check that a certificate was issued by us
  uuid                      String   @unique @db.VarChar
  studentId                 Int
  student                   student  @relation(fields: [studentId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  startDate                 DateTime
  matchesCount              Int
  matchAppointmentsCount    Int
  courseParticipantsCount   Int
  courseAppointmentsCount   Int
  totalAppointmentsDuration Int // in minutes
}

model pupil {
  id                           Int                   @id(map: "PK_34f2dbae733affb8884c2255c21") @default(autoincrement())
  createdAt                    DateTime              @default(now()) @db.Timestamp(6)
  updatedAt                    DateTime              @default(now()) @updatedAt @db.Timestamp(6)
  firstname                    String?               @db.VarChar
  lastname                     String?               @db.VarChar
  active                       Boolean               @default(true)
  email                        String                @unique(map: "IDX_24d523169870b7e80f9e68aad3") @db.VarChar
  // If set, the user email was verified:
  verifiedAt                   DateTime?             @db.Timestamp(6)
  // The account was anonymized, and all personal data was replaced with placeholders
  // (but still keep the entry to keep foreign keys consistent and for statistics):
  isRedacted                   Boolean               @default(false)
  // The last time the notification popup was opened in the App:
  lastTimeCheckedNotifications DateTime?             @default(dbgenerated("'1970-01-01 00:00:00'::timestamp without time zone")) @db.Timestamp(6)
  notificationPreferences      Json?                 @db.Json
  // The last time the user logged in to the Backend through GraphQL (= with the App):
  lastLogin                    DateTime?             @default(now()) @db.Timestamp(6)
  // DEPRECATED: We once had a registration form through Wix, the wix_id is still sometimes used as a foreign key
  // for users, as unlike pupil.id/student.id it is unique across entities
  wix_id                       String                @unique(map: "IDX_16c46adbb2885e591364e476e5") @db.VarChar
  wix_creation_date            DateTime              @db.Timestamp(6)
  state                        pupil_state_enum      @default(other)
  schooltype                   pupil_schooltype_enum @default(other)
  // DEPRECATED: ?
  msg                          String?               @db.VarChar
  grade                        String?               @db.VarChar
  // DEPRECATED: Replaced by notificationPreferences
  newsletter                   Boolean               @default(false)
  // 'isPupil' indicated whether a pupil wants to do tutoring, should rather be 'isTutee'
  isPupil                      Boolean               @default(false)
  // JSON with the format: [{ name: "Deutsch" }, { name: "Englisch", mandatory: true }]
  subjects                     String?               @db.VarChar
  // Number of matches a pupil wants to have, usually limited to one
  openMatchRequestCount        Int                   @default(1)
  firstMatchRequest            DateTime?             @db.Timestamp(6)
  // indicates whether a pupil wants to join courses, usually true
  isParticipant                Boolean               @default(true)

  languages                                    pupil_languages_enum[]                         @default([])
  learningGermanSince                          pupil_learninggermansince_enum?
  // Can be used to match some pupils earlier than others, rarely used
  matchingPriority                             Int                                            @default(0)
  lastUpdatedSettingsViaBlocker                DateTime?                                      @db.Timestamp(6)
  // Used some time ago when we had cooperations with certain schools:
  teacherEmailAddress                          String?                                        @db.VarChar
  // The regration form that was used by the pupil, mainly used to detect Lern-Fair Plus users
  registrationSource                           pupil_registrationsource_enum                  @default(normal)
  // DEPRECATED: We had a cooperation with the 'Codu Studie' and tracked specific users for that study:
  coduToken                                    String?                                        @unique(map: "UQ_530c5238700824af32352324363") @db.VarChar
  aboutMe                                      String                                         @default("") @db.VarChar
  matchReason                                  String                                         @default("") @db.VarChar
  schoolId                                     Int?
  school                                       school?                                        @relation(fields: [schoolId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_ed2282d6491ddb708d5b8f60225")
  course_attendance_log                        course_attendance_log[]
  course_participation_certificate             course_participation_certificate[]
  match                                        match[]
  participation_certificate                    participation_certificate[]
  pupil_screening                              pupil_screening[]
  pupil_tutoring_interest_confirmation_request pupil_tutoring_interest_confirmation_request[]
  subcourse_participants_pupil                 subcourse_participants_pupil[]
  waiting_list_enrollment                      waiting_list_enrollment[]
  gradeUpdatedAt                               DateTime?
  learning_topics                              learning_topic[]
  // There are cases where pupils prefer to be matched with a specific gender (e.g only with women)
  onlyMatchWith                                gender_enum?
  // Used to match pupils that have learning difficulties with students that have experience with these cases
  hasSpecialNeeds                              Boolean                                        @default(false)
  // Used as an "AboutMe" only for screening purposes. This field should not contain any sensitive information
  // about the pupil
  descriptionForScreening                      String                                         @default("") @db.VarChar
  // Screeners provide future matches tips or information about the pupil to help improve the collaboration
  descriptionForMatch                          String                                         @default("") @db.VarChar
  // The referring user's type and ID, e.g., "pupil/5", "student/3"
  referredById                                 String?                                        @db.VarChar

  // Sometimes pupils, specially younger ones, are registered with the email of a support person (parent, teacher, etc...)
  // Here we specify who is the owner of this email
  emailOwner pupil_email_owner_enum @default(unknown)
}

// To only match active users, we sent interest confirmation requests to pupils before matching them
// Now replaced by Pupil Screening, but still keeping it alive as it might be useful in the future again:
model pupil_tutoring_interest_confirmation_request {
  id               Int       @id(map: "PK_5f3515ba0bd182b1cc34f06ef11") @default(autoincrement())
  createdAt        DateTime  @default(now()) @db.Timestamp(6)
  updatedAt        DateTime  @default(now()) @updatedAt @db.Timestamp(6)
  status           String    @default("pending") @db.VarChar
  // invalidated if a Match was created or the Match Request was revoked
  invalidated      Boolean   @default(false)
  // DEPRECATED: Was used to offer a direct link for confirmation, now replaced by an important notification in the App
  token            String    @unique(map: "IDX_8108668f1658b14b9db299634e") @db.VarChar
  // DEPRECATED: Replaced by the Notification System
  reminderSentDate DateTime? @db.Timestamp(6)
  pupilId          Int?
  pupil            pupil?    @relation(fields: [pupilId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_5928ac6454eee0bfbdb8e538ef8")
}

// A Push Subcscription according to https://w3c.github.io/push-api/#pushsubscription-interface
model push_subscription {
  id             Int       @id @default(autoincrement())
  // relation to pupil, student, screener
  userID         String
  // The endpoint that can be pushed to
  endpoint       String
  // The time at which the subscription expires
  expirationTime DateTime?
  // Public key of the subscription which we can encrypt messages with
  // (so that only the user's device can decrypt them)
  keys           Json
}

// We require Students to hand in a Certificate of Conduct, for that we issue them a Remission Request to get it for free
model remission_request {
  id        Int      @id(map: "PK_4ea2cbe40d9d5cfe1d39a44558f") @default(autoincrement())
  createdAt DateTime @default(now()) @db.Timestamp(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamp(6)
  uuid      String   @unique(map: "IDX_2ede2092e5c464510c99fcfd05") @db.VarChar
  studentId Int?     @unique(map: "REL_5b96e9df53055059ad903ebc98")
  student   student? @relation(fields: [studentId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_5b96e9df53055059ad903ebc98c")
}

// Incomplete List of German Schools where our pupils come from
model school {
  id         Int                     @id(map: "PK_57836c3fe2f2c7734b20911755e") @default(autoincrement())
  createdAt  DateTime                @default(now()) @db.Timestamp(6)
  updatedAt  DateTime                @default(now()) @updatedAt @db.Timestamp(6)
  name       String                  @db.VarChar
  zip        String?                 @db.VarChar
  city       String?                 @db.VarChar
  email      String?                 @db.VarChar
  state      school_state_enum       @default(other)
  schooltype school_schooltype_enum? @default(other)
  pupil      pupil[]

  @@unique([name, state, city])
}

// A member of the Lern-Fair team doing screenings, there is one 'Default Screener' account used by Admins
// Historically there was a dedicated Screening Tool were screeners could log in.
// Nowadays Screenings are done via Retool, with the Default Screener
model screener {
  id                           Int                    @id(map: "PK_3a023b02ed01df4a6956af1ea94") @default(autoincrement())
  createdAt                    DateTime               @default(now()) @db.Timestamp(6)
  updatedAt                    DateTime               @default(now()) @updatedAt @db.Timestamp(6)
  firstname                    String?                @db.VarChar
  lastname                     String?                @db.VarChar
  active                       Boolean                @default(true)
  email                        String                 @unique(map: "IDX_29a6207bc70a2b9e6731d66bcf") @db.VarChar
  verifiedAt                   DateTime?              @db.Timestamp(6)
  isRedacted                   Boolean                @default(false)
  lastTimeCheckedNotifications DateTime?              @default(dbgenerated("'1970-01-01 00:00:00'::timestamp without time zone")) @db.Timestamp(6)
  notificationPreferences      Json?                  @db.Json
  lastLogin                    DateTime?              @default(now()) @db.Timestamp(6)
  // DEPRECATED, Use Secret instead
  password                     String                 @db.VarChar
  verified                     Boolean?               @default(false)
  // DEPRECATED:
  oldNumberID                  Int?                   @unique(map: "UQ_96dc11de485d62615e78a875293")
  instructor_screening         instructor_screening[]
  screenings                   screening[]
  is_trusted                   Boolean                @default(false)
  is_student_screener          Boolean                @default(false)
  is_pupil_screener            Boolean                @default(false)
  is_course_screener           Boolean                @default(false)
}

// A Screening for Students that want to tutor pupils
model screening {
  id                    Int                           @id(map: "PK_5111bc526c9133721aeffb9a578") @default(autoincrement())
  status                student_screening_status_enum @default(pending)
  comment               String?                       @db.VarChar
  jobStatus             screening_jobstatus_enum?
  // This is a String and not an enum to be able to quickly support further values without a DB migration,
  // and to be able to cover 'Sonstiges'. In the Screening Tooling, we however always write the same strings into it,
  // so a COUNT(*) GROUP BY should work relatively well:
  knowsCoronaSchoolFrom String?                       @db.VarChar
  createdAt             DateTime                      @default(now()) @db.Timestamp(6)
  updatedAt             DateTime                      @default(now()) @updatedAt @db.Timestamp(6)
  screenerId            Int?
  studentId             Int?                          @unique(map: "REL_dfb78fd7887c69e3c52e002083")
  screener              screener?                     @relation(fields: [screenerId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_c0b20c6342ac95d3b66c31ac30e")
  student               student?                      @relation(fields: [studentId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_dfb78fd7887c69e3c52e0020838")
  lecture               lecture[]
}

model student {
  id                                        Int                      @id(map: "PK_3d8016e1cb58429474a3c041904") @default(autoincrement())
  createdAt                                 DateTime                 @default(now()) @db.Timestamp(6)
  updatedAt                                 DateTime                 @default(now()) @updatedAt @db.Timestamp(6)
  firstname                                 String?                  @db.VarChar
  lastname                                  String?                  @db.VarChar
  active                                    Boolean                  @default(true)
  email                                     String                   @unique(map: "IDX_a56c051c91dbe1068ad683f536") @db.VarChar
  // If set, the user email was verified:
  verifiedAt                                DateTime?                @db.Timestamp(6)
  // The account was anonymized, and all personal data was replaced with placeholders
  // (but still keep the entry to keep foreign keys consistent and for statistics):
  isRedacted                                Boolean                  @default(false)
  lastTimeCheckedNotifications              DateTime?                @default(dbgenerated("'1970-01-01 00:00:00'::timestamp without time zone")) @db.Timestamp(6)
  notificationPreferences                   Json?                    @db.Json
  lastLogin                                 DateTime?                @default(now()) @db.Timestamp(6)
  // DEPRECATED: We once had a registration form through Wix, the wix_id is still sometimes used as a foreign key
  // for users, as unlike pupil.id/student.id it is unique across entities
  wix_id                                    String                   @unique(map: "IDX_545d0c66310ca5df98b4765cc7") @db.VarChar
  wix_creation_date                         DateTime                 @db.Timestamp(6)
  // DEPRECATED: This was intended to notify users via SMS, but never landed in the UI:
  phone                                     String?                  @db.VarChar
  feedback                                  String?                  @db.VarChar
  // DEPRECATED: Replaced by notificationPreferences
  newsletter                                Boolean                  @default(false)
  // Wether the user wants to do tutoring, should rather be 'isTutor'
  isStudent                                 Boolean                  @default(false)
  // JSON with the format: [{ name: "Deutsch", minGrade: 1, maxGrade: 10 }]
  subjects                                  String?                  @db.VarChar
  openMatchRequestCount                     Int                      @default(1)
  firstMatchRequest                         DateTime?                @db.Timestamp(6)
  // DEPRECATED:
  isCodu                                    Boolean                  @default(false)
  // Whether the user wants to do courses
  isInstructor                              Boolean                  @default(false)
  // DEPRECATED: ?
  msg                                       String?                  @db.VarChar
  state                                     student_state_enum?      @default(other)
  university                                String?                  @db.VarChar
  // DEPRECATED: Replaced by screening.jobInfo
  isUniversityStudent                       Boolean?
  // Might still be in use somewhere, is used to mark students that support in 'Deutsch als Zweitsprache'
  supportsInDaZ                             Boolean?
  languages                                 student_languages_enum[] @default([])
  // DEPRECATED: Replaced by Notification System
  sentScreeningReminderCount                Int                      @default(0)
  lastSentScreeningInvitationDate           DateTime?                @db.Timestamp(6)
  sentInstructorScreeningReminderCount      Int                      @default(0)
  lastSentInstructorScreeningInvitationDate DateTime?                @db.Timestamp(6)

  lastUpdatedSettingsViaBlocker    DateTime?                          @db.Timestamp(6)
  // The registration form used to register the user, mainly used to find Lern-Fair Plus students
  registrationSource               student_registrationsource_enum    @default(normal)
  aboutMe                          String                             @default("") @db.VarChar
  // Currently only Students can create Appointments with a Zoom Meeting, for that they need a Zoom Account:
  zoomUserId                       String?                            @db.VarChar
  certificate_of_conduct           certificate_of_conduct?
  course                           course[]
  course_guest                     course_guest[]
  course_instructors_student       course_instructors_student[]
  course_participation_certificate course_participation_certificate[]
  instructor_screening             instructor_screening?
  jufo_verification_transmission   jufo_verification_transmission?
  lecture                          lecture[]
  match                            match[]
  participation_certificate        participation_certificate[]
  instant_certificate              instant_certificate[]
  remission_request                remission_request?
  screening                        screening?
  subcourse_instructors_student    subcourse_instructors_student[]
  // Should stay null for users who where registered before the onboarding got added
  hasDoneEthicsOnboarding          Boolean?

  cooperationID           Int?
  cooperation             cooperation? @relation(fields: [cooperationID], references: [id])
  // Used to match students that have have experience supporting pupils with learning difficulties
  hasSpecialExperience    Boolean      @default(false)
  // Used as an "AboutMe" for screening or for other type of Meetings between Lern-Fair and the student
  descriptionForScreening String       @default("") @db.VarChar
  // Screeners provide future matches tips or information about the student to help improve the collaboration
  descriptionForMatch     String       @default("") @db.VarChar
  // Used to match pupils that may prefer be matched only with a specific gender. See pupil.onlyMatchWith
  gender                  gender_enum?

  // The referring user's type and ID, e.g., "pupil/5", "student/3"
  referredById              String?                     @db.VarChar
  subcourse_mentors_student subcourse_mentors_student[]
}

// A concrete course with participants, each course might have multiple subcourses with different instructors
model subcourse {
  id                               Int                                @id(map: "PK_304edeed9f68de88999028fe80e") @default(autoincrement())
  createdAt                        DateTime                           @default(now()) @db.Timestamp(6)
  updatedAt                        DateTime                           @default(now()) @updatedAt @db.Timestamp(6)
  minGrade                         Int
  maxGrade                         Int
  maxParticipants                  Int
  joinAfterStart                   Boolean                            @default(false)
  published                        Boolean
  publishedAt                      DateTime?                          @db.Timestamp(6)
  cancelled                        Boolean                            @default(false)
  // DEPRECATED: In favor of subcourse_promotions
  alreadyPromoted                  Boolean                            @default(false)
  // Usually we derive the ChatID from the ids of the users in the Chat, but as the Chat Participants
  // of a Subcourse might change, we create a random ID for it and store it:
  conversationId                   String?                            @db.VarChar
  // conversation IDs of prospect chats
  // (not an injective relation, one conversation can be a prospect chat for multiple subcourses)
  prospectChats                    Json[]                             @default([]) @db.Json
  allowChatContactProspects        Boolean                            @default(true)
  allowChatContactParticipants     Boolean                            @default(true)
  groupChatType                    chat_type                          @default(NORMAL)
  courseId                         Int?
  course                           course?                            @relation(fields: [courseId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_274b57f6af62ffadb80afcbae85")
  course_participation_certificate course_participation_certificate[]
  lecture                          lecture[]
  subcourse_instructors_student    subcourse_instructors_student[]
  subcourse_participants_pupil     subcourse_participants_pupil[]
  waiting_list_enrollment          waiting_list_enrollment[]
  subcourse_promotions             subcourse_promotion[]
  subcourse_mentors_student        subcourse_mentors_student[]
}

model subcourse_promotion {
  id          Int                           @id @default(autoincrement())
  createdAt   DateTime                      @default(now()) @db.Timestamp(6)
  type        subcourse_promotion_type_enum
  subcourse   subcourse                     @relation(fields: [subcourseId], references: [id], onDelete: Cascade)
  subcourseId Int
}

// These students only support pupils in the course. They don't own the course/subcourse (so, no edition rights)
// They can join/leave courses that allow mentors (For now only used the Hausaufgabenhilfe)
// They don't count as course participants (e.g for maxParticipants, referrals, etc...)
model subcourse_mentors_student {
  subcourseId Int
  studentId   Int
  subcourse   subcourse @relation(fields: [subcourseId], references: [id], onDelete: Cascade)
  student     student   @relation(fields: [studentId], references: [id], onDelete: NoAction, onUpdate: NoAction)

  @@id([subcourseId, studentId])
}

// This is redundant with the Appointment.organizerIds of the appointments attached to the Subcourse and should generally be in sync
model subcourse_instructors_student {
  subcourseId Int
  studentId   Int
  subcourse   subcourse @relation(fields: [subcourseId], references: [id], onDelete: Cascade, map: "FK_3f0c594b9393bf4ca9ed3681967")
  student     student   @relation(fields: [studentId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_b36e4eeff8040a09cc811dbb262")

  @@id([subcourseId, studentId], map: "PK_e41756ec54d1828c27b0a5dc055")
  @@index([subcourseId], map: "IDX_3f0c594b9393bf4ca9ed368196")
  @@index([studentId], map: "IDX_b36e4eeff8040a09cc811dbb26")
}

// This is redundant with the Appointment.participantIds of the appointments attached to the Subcourse and should generally be in sync
model subcourse_participants_pupil {
  subcourseId Int
  pupilId     Int
  pupil       pupil     @relation(fields: [pupilId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_47d9d98b6496554165e08ff61d9")
  subcourse   subcourse @relation(fields: [subcourseId], references: [id], onDelete: Cascade, map: "FK_cde91c063947d1302d50c906dcd")

  @@id([subcourseId, pupilId], map: "PK_7b8738e08eab7b5bf796f0eaf1b")
  @@index([pupilId], map: "IDX_47d9d98b6496554165e08ff61d")
  @@index([subcourseId], map: "IDX_cde91c063947d1302d50c906dc")
}

// We require a Certifcate of Conduct to be handed in by Students, which is verified by Support
model certificate_of_conduct {
  id               Int      @id(map: "PK_95058dd1916a7fb5ff77170c374") @default(autoincrement())
  createdAt        DateTime @default(now()) @db.Timestamp(6)
  updatedAt        DateTime @default(now()) @updatedAt @db.Timestamp(6)
  // Filled by support:
  dateOfInspection DateTime @db.Timestamp(6)
  dateOfIssue      DateTime @db.Timestamp(6)
  criminalRecords  Boolean

  studentId Int?     @unique(map: "REL_11ea2a4aad67ab6428a6ca21b4")
  student   student? @relation(fields: [studentId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_11ea2a4aad67ab6428a6ca21b41")
}

// Every time we run the matching algorithm, we collect its stats:
model match_pool_run {
  id             Int      @id(map: "PK_94a8e7729d108dfa44fb65c1a10") @default(autoincrement())
  // By filtering Match.createdAt that are close to runAt, one can find the matches created by this run:
  runAt          DateTime @default(now()) @db.Timestamp(6)
  matchingPool   String   @db.VarChar
  matchesCreated Int
  stats          Json     @db.Json

  matches match[]
}

// A Secret allows a User to log in, i.e. a Token sent to the user via Email or their Password
model secret {
  id               Int              @id(map: "PK_6afa4961954e17ec2d6401afc3d") @default(autoincrement())
  createdAt        DateTime         @default(now()) @db.Timestamp(6)
  userId           String           @db.VarChar
  type             secret_type_enum
  secret           String           @db.VarChar
  expiresAt        DateTime?        @db.Timestamp(6)
  lastUsed         DateTime?        @db.Timestamp(6)
  // For Tokens created on a device, this contains the User-Agent of the Device
  // Might also be 'Support' if someone from Support logs in on behalf of the user
  // For EMAIL_TOKENs, contains the email the token is sent to. Can be used to confirm additional email addresses
  // (i.e. during email address change)
  description      String?          @db.VarChar
  lastUsedDeviceId String?          @db.VarChar // the permanent device identifier this secret was last used on
  idpClientId      String?          @db.VarChar
}

// DEPRECATED: Used by our old ORM to track migrations, to be removed once Prisma Migrations work reliably
/// The underlying table does not contain a valid unique identifier and can therefore currently not be handled by the Prisma Client.
model typeorm_metadata {
  type     String  @db.VarChar
  database String? @db.VarChar
  schema   String? @db.VarChar
  table    String? @db.VarChar
  name     String? @db.VarChar
  value    String?

  @@ignore
}

// A Message Template for a Notification in a specific language
model message_translation {
  id             Int                               @id(map: "PK_159f92cfb8a0b269fbc863c74ee") @default(autoincrement())
  template       Json?                             @db.Json
  navigateTo     String?
  language       message_translation_language_enum @default(de)
  notificationId Int?
  notification   notification?                     @relation(fields: [notificationId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_5ae486c5ef53f5335af8a4ae260")
}

// An important information shown on the landing page of the App:
model important_information {
  id          Int                                   @id(map: "PK_bcd2068ca02cc6f323bf01754a5") @default(autoincrement())
  title       String
  description String
  recipients  important_information_recipients_enum
  navigateTo  String?
  language    important_information_language_enum   @default(de)
}

// Before matching a pupil, in some match pools we ask them to do a screening beforehand:
model pupil_screening {
  id          Int                         @id(map: "PK_3b4bba5fc1846edc712915c9dfa") @default(autoincrement())
  createdAt   DateTime                    @default(now()) @db.Timestamp(6)
  updatedAt   DateTime                    @default(now()) @updatedAt @db.Timestamp(6)
  status      pupil_screening_status_enum @default(pending)
  // invalidated when a student dissolves a match due to Ghosting / Personal Issues, OR if the last successful screening is older than 4 months (calculated at time of requesting a new match)
  invalidated Boolean                     @default(false)
  comment     String?                     @db.VarChar
  pupilId     Int?
  pupil       pupil?                      @relation(fields: [pupilId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_d53a566dbe1a58b06bea8b51c1d")

  // During the Pupil Screening, various screeners are involved ('four eye principle')
  // This was not tracked before September 23
  screenerIds           Int[]     @default([])
  // This is a String and not an enum to be able to quickly support further values without a DB migration,
  // and to be able to cover 'Sonstiges'. In the Screening Tooling, we however always write the same strings into it,
  // so a COUNT(*) GROUP BY should work relatively well:
  knowsCoronaSchoolFrom String?   @db.VarChar
  lecture               lecture[]
}

// When a subcourse is already full, pupils can still enroll on a waiting list
// The instructors can then decide to accept them as participants
model waiting_list_enrollment {
  id          Int        @id(map: "PK_7c3bb40b03f8c4e1325ed4df416") @default(autoincrement())
  createdAt   DateTime   @default(now()) @db.Timestamp(6)
  pupilId     Int?
  subcourseId Int?
  subcourse   subcourse? @relation(fields: [subcourseId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_4c3bda70e61547bcdb61e85a110")
  pupil       pupil?     @relation(fields: [pupilId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_c019519c21578e119799586d7ed")
}

// Synchronizes Job Runs across Dynos
model job_run {
  job_name  String
  startedAt DateTime  @default(now()) @db.Timestamp(6)
  endedAt   DateTime? @db.Timestamp(6)
  worker    String

  @@id([job_name, startedAt])
}

enum notification_channel_enum {
  email
  inapp
  push
}

enum subcourse_promotion_type_enum {
  system
  instructor
  admin
}

enum course_category_enum {
  language
  focus
  revision
  club
  coaching
  homework_help
}

enum course_coursestate_enum {
  created
  submitted
  allowed
  denied
  cancelled
}

enum log_logtype_enum {
  misc
  verificationRequets // sic!
  verified
  matchDissolve
  fetchedFromWix
  deActivate
  updatePersonal
  updateSubjects
  accessedByScreener
  updatedByScreener
  updateStudentDescription
  createdCourse
  certificateRequest
  cocCancel
  cancelledCourse
  cancelledSubcourse
  createdCourseAttendanceLog
  bbbMeeting
  participantJoinedCourse
  participantLeftCourse
  mentorJoinedCourse
  mentorLeftCourse
  participantJoinedWaitingList
  participantLeftWaitingList
  userAccessedCourseWhileAuthenticated
  instructorIssuedCertificate
  pupilInterestConfirmationRequestSent
  pupilInterestConfirmationRequestReminderSent
  pupilInterestConfirmationRequestStatusChange
  skippedCoC
}

enum pupil_languages_enum {
  Albanisch
  Arabisch
  Armenisch
  Aserbaidschanisch
  Bosnisch
  Bulgarisch
  Chinesisch
  Deutsch
  Englisch
  Franz_sisch       @map("Französisch")
  Italienisch
  Kasachisch
  Kurdisch
  Polnisch
  Portugiesisch
  Russisch
  T_rkisch          @map("Türkisch")
  Spanisch
  Ukrainisch
  Vietnamesisch
  Andere
}

enum pupil_learninggermansince_enum {
  more_than_four @map(">4")
  two_to_four    @map("2-4")
  one_to_two     @map("1-2")
  less_than_one  @map("<1")
}

enum pupil_registrationsource_enum {
  normal      @map("0")
  cooperation @map("1")
  drehtuer    @map("2")
  other       @map("3")
  codu        @map("4")
  plus        @map("5")
}

enum pupil_schooltype_enum {
  grundschule
  gesamtschule
  hauptschule
  realschule
  gymnasium
  f_rderschule @map("förderschule")
  berufsschule
  other
}

enum pupil_state_enum {
  bw
  by
  be
  bb
  hb
  hh
  he
  mv
  ni
  nw
  rp
  sl
  sn
  st
  sh
  th
  at
  ch
  other
}

enum school_schooltype_enum {
  grundschule
  gesamtschule
  hauptschule
  realschule
  gymnasium
  f_rderschule @map("förderschule")
  berufsschule
  other
}

enum school_state_enum {
  bw
  by
  be
  bb
  hb
  hh
  he
  mv
  ni
  nw
  rp
  sl
  sn
  st
  sh
  th
  at
  ch
  other
}

enum student_languages_enum {
  Albanisch
  Arabisch
  Armenisch
  Aserbaidschanisch
  Bosnisch
  Bulgarisch
  Chinesisch
  Deutsch
  Englisch
  Franz_sisch       @map("Französisch")
  Italienisch
  Kasachisch
  Kurdisch
  Polnisch
  Portugiesisch
  Russisch
  T_rkisch          @map("Türkisch")
  Spanisch
  Ukrainisch
  Vietnamesisch
  Andere
}

enum student_module_enum {
  internship
  seminar
  other
}

enum student_registrationsource_enum {
  normal      @map("0")
  cooperation @map("1")
  drehtuer    @map("2")
  other       @map("3")
  codu        @map("4")
  plus        @map("5")
}

enum student_state_enum {
  bw
  by
  be
  bb
  hb
  hh
  he
  mv
  ni
  nw
  rp
  sl
  sn
  st
  sh
  th
  at
  ch
  other
}

enum notification_sender_enum {
  SUPPORT
  CERTIFICATE_OF_CONDUCT
}

enum achievement_template_for_enum {
  Course
  Global_Courses
  Match
  Global_Matches
  Global
}

enum achievement_type_enum {
  SEQUENTIAL
  TIERED
  STREAK
}

enum achievement_action_type_enum {
  Appointment
  Action
  Wait
  Info
}

enum secret_type_enum {
  PASSWORD
  TOKEN
  EMAIL_TOKEN
  IDP
}

enum course_schooltype_enum {
  grundschule
  gesamtschule
  hauptschule
  realschule
  gymnasium
  f_rderschule @map("förderschule")
  berufsschule
  other
}

enum course_subject_enum {
  Altgriechisch
  Arbeitslehre
  Biologie
  Chemie
  Deutsch
  Deutsch_als_Zweitsprache @map("Deutsch als Zweitsprache")
  Englisch
  Erdkunde
  Ethik
  Franz_sisch              @map("Französisch")
  Geschichte
  Gesundheit
  Informatik
  Italienisch
  Kunst
  Latein
  Mathematik
  Musik
  Niederl_ndisch           @map("Niederländisch")
  P_dagogik                @map("Pädagogik")
  Philosophie
  Physik
  Politik
  Religion
  Russisch
  Sachkunde
  Spanisch
  Technik
  Wirtschaft
  Lernen_lernen            @map("Lernen lernen")
}

enum message_translation_language_enum {
  en
  de
}

enum notification_type_enum {
  chat
  survey
  appointment
  advice
  suggestion
  announcement
  call
  news
  event
  request
  alternative
  account
  onboarding
  match
  course
  certificate
  legacy
  achievement
}

enum important_information_language_enum {
  en
  de
}

enum important_information_recipients_enum {
  students
  pupils
}

enum pupil_screening_status_enum {
  pending   @map("0")
  success   @map("1")
  rejection @map("2")
  dispute   @map("3")
}

enum lecture_appointmenttype_enum {
  group
  match
  internal
  // Users need to go through a screening process before they can use the app. 
  // For this they have to book an appointment in Calendly.
  // The appointment is then automatically stored in the lecture table with this type via a webhook.
  screening
  legacy
}

enum chat_type {
  NORMAL
  ANNOUNCEMENT
}

enum screening_jobstatus_enum {
  Student
  Pupil
  Employee
  Retiree
  Misc
}

enum dissolved_by_enum {
  pupil
  student
  admin
  unknown
}

enum dissolve_reason {
  accountDeactivated // The account was deactivated, causing any active matches to be dissolved automatically
  accountDeactivatedNoCoC // The account was deactivated because the student did not hand in a Certificate of Conduct
  ghosted // "Mein:e Lernpartner:in hat sich nicht zurückgemeldet"
  noMoreHelpNeeded // "Mein:e Lernpartner:in benötigt keine Unterstützung mehr" and "Ich benötige keine Unterstützung mehr"
  isOfNoHelp // "Ich konnte meinem/meiner Lernpartner:in nicht behilflich sein" and "Mein:e Lernpartner:in konnte mir nicht behilflich sein"
  noMoreTime // "Ich habe keine Zeit mehr mein*e Lernpartner:in zu unterstützen" and "Mein:e Lernpartner:in hat keine Zeit mehr mich zu unterstützen"
  personalIssues // "Wir hatten Schwierigkeiten auf zwischenmenschlicher Ebene"
  scheduleIssues // "Wir konnten keine gemeinsamen Termine finden"
  technicalIssues // "Wir hatten technische Schwierigkeiten"
  languageIssues // "Wir hatten sprachliche Schwierigkeiten"
  other // "Sonstiges"
  unknown // legacy data which we can't map anymore
}

enum gender_enum {
  male
  female
  other
}

enum pupil_email_owner_enum {
  pupil
  parent
  other
  unknown
}

enum student_screening_status_enum {
  pending   @map("0")
  success   @map("1")
  rejection @map("2")
  missed    @map("3")
}
